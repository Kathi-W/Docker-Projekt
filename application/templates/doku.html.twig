{% extends "layout.html.twig" %}

{% block content %}

    <div class="doku">
    <h4>Meine Aufgabe</h4>
    <p>
        Ich möchte eine Symfony Web Applikation mit Datenbankanbindung erstellen.
        Dafür benötige ich:
        <ul>
            <li>Ein Symfony Skeleton</li>
            <li>Einen Webserver, ich verwende Nginx</li>
            <li>Eine Datenbank</li>
            <li>PHP</li>
        </ul>

        Mein Ziel ist es, eine Applikation für Rezepte zu erstellen. Man soll Rezepte anlegen, bearbeiten und löschen können, sowie alle Rezepte anzeigen.
    </p>

    <h4>Erstellung der Symfony Applikation</h4>
    <p>
        Symfony bietet ein WebApp Skelett. Dieses lässt sich mit dem Befehl <code>composer create-project symfony/website-skeleton my-project</code> erstellen.
        Es wird eine Verzeichnisstruktur erstellt, die wie folgt aussieht:
        <pre><code>
                Symfony-Anwendung/
                ├─ bin/
                │  └─ console
                ├─ config/
                └─ public/
                │  └─ index.php
                ├─ src/
                │  └─ Kernel.php
                ├─ templates/
                ├─ tests/
                ├─ var/
                │  ├─ cache/
                │  └─ log/
                └─ vendor/
            </code></pre>

        Die eigentliche Anwendung befindet sich später unter <code>src</code>. Dort werden der Controller, die Entities sowie die Repositories angelegt.
        Symfony arbeitet mit der template engine <strong>twig</strong>. Die html.twig Dateien werden im Verzeichnis <code>templates</code> gespeichert.
    </p>

    <h4>Das Docker Verzeichnis</h4>
    <p>
        Als nächstes habe ich auf der gleichen Ebene wie die Symfony-Anwendung ein neues Verzeichnis <strong>docker</strong> angelegt.
        Dort benötige ich als erstes eine <code>docker-compose.yml</code>, da ich mehrere Docker Container benötige.
        Als erstes muss ich die Version festlegen. Hierbei habe ich mich für Version 2 anstatt der neueren Verion 3 entschieden, da
        diese für unerfahrene Docker Benutzer einfacher zu benutzen ist.
        Als nächstes müssen die vier Services definiert werden:
    </p>

    <ul>
        <li><strong>nginx</strong>: Hier wird der Port, laut Projekt-Vorgaben, auf 19040 gesetzt und ein Link zu php gesetzt. Im Verzeichnis <code>docker/nginx</code>
        liegt der Dockerfile für den build und eine config Datei.</li>
        <li><strong>php</strong>:</li>
        <li><strong>mysql</strong>:Für diesen Container habe ich das mysql:5 image aus dem offiziellen Repository verwendet. Da die neueste Version 8 sha256 hashing verwendet und
        dies nicht mit dem php client kompatibel ist, habe ich die Version 5 verwendet.</li>
        <li><strong>compose</strong>: Dieser Container soll dafür sorgen, dass Composer installiert wird, sowie dass die Datenbank upgedated wird
        Dafür sorgt <code>command: bash -c "wait-for-it -t 90 mysql:3306 && composer install && php bin/console doctrine:schema:update --force"</code>
        Das Kommando <code>wait-for-it</code> sorgt dafür, dass diese Befehle auf jeden Fall erst ausgeführt werden, wenn die anderen Container fertig sind, insbesondere
        der mysql Container. Ansonsten entsteht eine race condition und es kann dazu kommen, dass das sql zu früh geladen wird.</li>
    </ul>

    <p>
        <h4>Die Datenbank anbinden</h4>
        Um die Datenbank richtig anzubinden, müssen zunächst die environment Variablen im <code>docker-compose.yml</code> richtig gesetzt werden.
        Mit <strong>MYSQL_ROOT_PASSWORD</strong> wird das Passwort der Datenbank gesetzt, mit <strong>MYSQL_DATABASE</strong> der Name und mit
        <strong>MYSQL_USER</strong> den Usernamen.
    </p>
    <p>
        Mit <code>mysql -u root -p -h 127.0.0.1 --port 3306</code> kann nun die Verbindung zur Datenbank hergestellt werden.
    </p>

    <h4>Aufbau Der Web Applikation</h4>
    <p>
        Für die Datenbank habe ich zunächst ein Schema erstellt.
        Dann habe ich die zwei Entities <strong>Recipe</strong> und <strong>Ingredient</strong> und die dazugehörigen Repositories erstellt.
        <strong>Recipe</strong> hat die Properties id, title, note und ingredients. <strong>Ingredient</strong> hat die Properties id, recipe und ingredient.
        Danach habe ich die benötigten getter und setter Methoden erstellt. Die Repositories haben jeweils eine <code>save()</code> und eine <code>delete()</code>
        Methode.
    </p>
    <p>
        Als nächstes wird eine <code>mapping.orm.xml</code> benötigt. Für beide Entities wird ein Primärschlüssel mit dem <code>id-Tag</code> angelegt.
        Alle weiteren Felder werden mit dem <code>field-Tag</code> definiert.
    </p>

    <p>
        Der <code>RecipeController</code> enthält alle Funktionen für die verschiedenen Vorgänge und die <code>html.twig</code> Dateien habe ich die
        Applikation gestaltet. Dazu habe ich Bootstrap verwendet. Die <code>layout.html.twig</code> enthält das Grundgerüst der Applikation und alle anderen
        html.twig Dateien leiten davon ab.
    </p>
    <p>
        Dann muss die <code>routing.yaml</code> und die <code>services.yaml</code> befüllt werden.
        In der <code>routing.yaml</code> müssen alle Routen und die dazugehörige Funktion im Controller festgehalten werden.
        Außerdem kann auch die Methode, z.B. POST oder GET definiert werden.
        In der <code>services.yaml</code> müssen Entities und Repositories definiert werden, um sie als Service im Controller
        verwenden zu können.
    </p>

    <p>
        <h4>Schwierigkeiten</h4>

    </p>
    <h4></h4>
    </div>
{% endblock %}

{#mapping.orm.xml: entity name= namespace + Klassenname (in composer.json)#}
{#"autoload": {#}
{#"psr-4": {#}
{#"App\\": "src/"#}
{#},#}
